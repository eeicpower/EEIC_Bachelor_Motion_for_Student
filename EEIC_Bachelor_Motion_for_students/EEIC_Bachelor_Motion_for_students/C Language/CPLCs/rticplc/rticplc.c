#include <gplib.h>
#include <stdio.h>
#include <dlfcn.h>
#include <math.h>
//----------------------------------------------------------------------------------
// pp_proj.h is the C header for accessing PMAC Global, CSGlobal, Ptr vars
// _PPScriptMode_ for Pmac Script like access global & csglobal
// _EnumMode_ for Pmac enum data type checking on Set & Get global functions
//------------------------------------------------------------------------------------
// #define _PPScriptMode_	// uncomment for Pmac Script type access
// #define _EnumMode_			// uncomment for Pmac enum data type checking on Set & Get global functions		

#include "../../Include/pp_proj.h"
#include <RtGpShm.h>

#include "../../Libraries/ctrl/ctrl_step.h"
#include "../../Libraries/ctrl/ctrl_chirp.h"
#include "../../Libraries/ctrl/ctrl_func.h"
#include "../../Libraries/hardw_cdrv/hardw_cdrv.h"
#include "rticplc.h"

#define STEP_TIME 0.0010 // [s]
#define ENC_PULSE 312500 // [number]
#define TRQ_CONST 0.9800 // [Nm/V]

int counter = 0;    // time in millesec
double timer = 0.0;  // real time in sec

int flag_init = 1;    // if flag_init = 1, initialize
int flag_exptype = 0; // if flag_exptype = 1, chirp signal / flag_exptype=2, PID control algorithm starts

double ref_out = 0.0;// reference command generated by function ctrl_step      
extern volatile TF2_INF		gstCpidInf[1];
extern volatile TF2_INF		gstCpidAWUInf[1]; //AWU
extern volatile TF1_INF		gstCpdInf[1];
extern volatile TF2_INF		gstLPFInf[1];
double ctrl_cmd=0.0; //input to a motor[V]
double v0 = 0.0;
double v1 = 0.0;
double v2 = 0.0;
double temp1 = 0.0;
double temp2 = 0.0;
double vdistsim = 0.0;
double const_ref_num = 0.0;
double initial_pos_num = 0.0;
double amp_sinref_num = 0.0;
double qout = 0.0;
double invqout = 0.0;
double vdistest = 0.0;
double ctrl_error = 0.0;
double ctrl_gainout = 0.0;
double ctrl_satin = 0.0;
double ctrl_fbout = 0.0;
double ctrl_out_min = 0.0;
double ctrl_out_max = 0.0;
double ctrl_satout = 0.0;
extern volatile TF2_INF		LFmath[1];
extern volatile TF2_INF		INVQmath[1];
int flg_chirp = 0;
int jj = 0;

// メインルーチン（タイマー割り込みにより一定時間隔で呼ばれる）
void realtimeinterrupt_plcc()
{	
	//don't change
	volatile struct GateArray3  *MyGate3;//
	MyGate3 = GetGate3MemPtr(0); //

	// P variables input
	flag_exptype = pshm->P[50];

	//initialize shirato added for FB control
	// 1回目だけ実行される初期化ルーチン
	if (flag_init == 1) {
		func_TF2StateInit( &gstCpidInf[0] ); //initialize of Cfb
		func_CpidParaInit( &gstCpidInf[0]); //setting parameters of Cfb
		func_TF2StateInit( &gstCpidAWUInf[0] ); //initialize of Cfb with AWU
		func_CpidAWUParaInit(&gstCpidAWUInf[0]);
		func_TF1StateInit( &gstCpdInf[0]);
		func_CpdParaInit( &gstCpdInf[0]);
		func_TF2StateInit( &LFmath[0]);
		func_LFmathParaInit( &LFmath[0]);
		func_TF2StateInit( &INVQmath[0]);
		func_INVQmathParaInit( &INVQmath[0]); 

		flag_init = 0;
		initial_pos_num = pshm->Motor[1].ActPos; //num
	}

	// update sensor data
	motor_pos_rad = (pshm->Motor[1].ActPos - initial_pos_num) / ENC_PULSE * 2 * M_PI;
  motor_vel_rads = pshm->Motor[1].ActVel / ENC_PULSE * 2 * M_PI * STEP_TIME;

	// update timer data
	timer = counter * STEP_TIME;
 
	// P50 = 0: 制御入力0を出力する。（＝何もしない）
	if (flag_exptype == 0) {
		torque_cmd_Nm = 0.0;
		counter = 0;
	}

	// P50 = 1: チャープサインによるシステム同定。
	if (flag_exptype == 1) {
		ctrl_chirp(timer, &torque_cmd_Nm); // linear chirp
		counter++;
	}

	// P50 = 2: PD, PID制御。
	if (flag_exptype==2) {
		//step reference (angle ref [rad], start time [s], end time [s], current time [s], position reference [rad])
		ctrl_step_input_with_end(M_PI/2.0, 0, 5, timer, &pos_ref_rad); //make step reference

		//sin wave input
		//pos_ref_rad = amp_sinref_rad * sin(2 * M_PI * timer);

		// 5秒間だけ制御する。
		if (t<5){
			// PID制御はこちらをコメント解除して使う
			//ctrl_cmd = func_TF2Exe( pshm->Motor[1].PosError, &gstCpidInf[0],-5.0,5.0);//FB control output: ctrl_cmd[V]

			//AWUつきPID制御はこちらをコメント解除して使う
			ctrl_error = pshm->Motor[1].PosError;    
			ctrl_gainout = Cz_b0 * ctrl_error;//gain b0
			ctrl_satin = ctrl_gainout - ctrl_fbout;
			ctrl_out_min = 0.0;//limit voltage change
			ctrl_out_max = 0.0;//limit voltage change				
			if(ctrl_satin > ctrl_out_max){
				ctrl_satout = ctrl_out_max;
			} else if(ctrl_satin < ctrl_out_min){
				ctrl_satout = ctrl_out_min;
			} else {
				ctrl_satout = ctrl_satin;
			}
			ctrl_fbout = func_TF2Exe( ctrl_satout, &gstCpidAWUInf[0]);


			// PD制御はこちらをコメント解除して使う
			torque_cmd_Nm = func_TF1Exe(pos_error_rad, &gstCpdInf[0]); //FB control output
		}
		else {
			torque_cmd_Nm = 0.0;
		}
		counter++;
	}

	// P50 = 3: PPD制御 + 外乱オブザーバ。
	if (flag_exptype==3) {
		// 位置指令値
		pos_ref_rad = 0.0;

		pos_error_rad = pos_ref_rad - motor_pos_rad;
		v0 = func_TF1Exe(pos_error_rad, &gstCpdInf[0]); // FB control output
		v2 = qout - invqout;

		// 初期値応答が収束するまでDOBを動かさない。とりあえず1秒。
		// 常に外乱オブザーバを入れない場合はv1 = v0; のみ残し残りをコメントアウトする。
		if (timer > 1) {
			v1 = v0 + v2; 
		}
		else {
			v1 = v0;
		}
		vdistest = -v2;
		qout = func_TF2Exe(v1, &LFmath);
		invqout = func_TF2Exe(motor_pos_rad, &INVQmath);

		//外乱入力
		vdistsim = 0;
		// シミュレーション開始から2秒後にステップ外乱
		if (timer > 2) {
			vdistsim = 2;
		}

		torque_cmd_Nm = v1 + vdistsim;
		
		counter++;
	}

	// send torque input to the hardware
	hardw_trqref(torque_cmd_Nm);

	// P変数の定義 P変数のみをPMACと送受信できる？？
	// P variables output
	pshm->P[1]  = motor_vel_rads;
	pshm->P[2]  = pos_ref_rad;
	pshm->P[3]  = pos_error_rad;
	pshm->P[5]  = torque_cmd_Nm;
	pshm->P[6]  = motor_pos_rad;
	pshm->P[7]  = v0;
	pshm->P[8]  = v1;
	pshm->P[9]  = vdistsim;
	pshm->P[10] = vdistest;
	pshm->P[98] = timer;
	pshm->P[99] = counter;
	pshm->P[100] = initial_pos_num;
}


	 








